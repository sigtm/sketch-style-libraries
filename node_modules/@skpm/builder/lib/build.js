#!/usr/bin/env node
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let copyManifest = (() => {
  var _ref = _asyncToGenerator(function* (manifestJSON) {
    return new Promise(function (resolve, reject) {
      const copy = _extends({}, manifestJSON);
      copy.version = manifestJSON.version || skpmConfig.version;
      copy.description = manifestJSON.description || skpmConfig.description;
      copy.homepage = manifestJSON.homepage || skpmConfig.homepage;
      copy.name = manifestJSON.name || skpmConfig.name;
      copy.disableCocoaScriptPreprocessor = typeof manifestJSON.disableCocoaScriptPreprocessor === 'undefined' ? true : manifestJSON.disableCocoaScriptPreprocessor;

      if (manifestJSON.appcast !== false && skpmConfig.appcast !== false) {
        copy.appcast = manifestJSON.appcast || skpmConfig.appcast || defaultAppcastURL;
      } else {
        delete copy.appcast;
      }

      if (!copy.author && skpmConfig.author) {
        let author = skpmConfig.author;

        if (typeof skpmConfig.author === 'string') {
          author = (0, _parseAuthor2.default)(skpmConfig.author);
        }
        copy.author = author.name;
        if (!copy.email && author.email) {
          copy.email = author.email;
        }
      }

      copy.commands = manifestJSON.commands.map(function (command) {
        const basename = _path2.default.basename(command.script);
        return _extends({}, command, { script: basename });
      });

      _fs2.default.writeFile(_path2.default.join(output, 'Contents', 'Sketch', 'manifest.json'), JSON.stringify(copy, null, 2), function (err) {
        if (err) {
          reject(new Error(`Error while writing the manifest: ${err.message}`));
          return;
        }
        resolve();
      });
    });
  });

  return function copyManifest(_x) {
    return _ref.apply(this, arguments);
  };
})();

let buildCommandsAndResources = (() => {
  var _ref2 = _asyncToGenerator(function* (commands, resources, watch) {
    const webpackConfig = yield (0, _webpackConfig2.default)(argv, output, manifestFolder, skpmConfig);

    const compilers = [];

    for (var _iterator = commands.concat(resources), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref3 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref3 = _i.value;
      }

      const command = _ref3;

      const file = command.script || command;
      const compiler = (0, _webpack2.default)((yield webpackConfig(file, command.identifiers, command.handlers)));
      if (watch) {
        compilers.push(compiler.watch({}, buildCallback(file, watch)));
      } else {
        compiler.run(buildCallback(file));
      }
    }

    return compilers;
  });

  return function buildCommandsAndResources(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

let buildPlugin = (() => {
  var _ref4 = _asyncToGenerator(function* () {
    let manifestJSON;
    try {
      // delete the require cache so that we can require it anew (when watching)
      delete require.cache[manifest];
      manifestJSON = require(manifest);
    } catch (err) {
      console.error(err);
      process.exit(1);
    }

    const commands = getCommands(manifestJSON);
    const resources = getResources(skpmConfig);
    steps = commands.length + resources.length + 1;

    const now = Date.now();

    // start by copying the manifest
    try {
      yield copyManifest(manifestJSON);
    } catch (err) {
      console.error(`${_chalk2.default.red('error')} Error while copying ${skpmConfig.manifest}`);
      console.error(err);
      if (!argv.watch) {
        process.exit(1);
      }
    }

    if (!argv.watch) {
      console.log(`${_chalk2.default.dim(`[${counter + 1}/${steps}]`)} ðŸ–¨  Copied ${_chalk2.default.blue(skpmConfig.manifest)} in ${_chalk2.default.grey(Date.now() - now)}ms`);
      checkEnd();
    } else {
      console.log(`ðŸ–¨  Copied ${_chalk2.default.blue(skpmConfig.manifest)} in ${_chalk2.default.grey(Date.now() - now)}ms`);
    }

    // and then, build the commands
    return buildCommandsAndResources(commands, resources, argv.watch);
  });

  return function buildPlugin() {
    return _ref4.apply(this, arguments);
  };
})();

let buildAndWatchPlugin = (() => {
  var _ref5 = _asyncToGenerator(function* () {
    let compilers = yield buildPlugin();

    if (argv.watch) {
      _fs2.default.watch(manifest, _asyncToGenerator(function* () {
        // manifest has changed, we need to rebuild the plugin entirely

        if (compilers && compilers.length) {
          // if we are watching the commands, close the watchers first
          yield Promise.all(compilers.map(function (c) {
            return new Promise(function (resolve) {
              if (c) {
                c.close(resolve);
              } else {
                resolve();
              }
            });
          }));
        }

        compilers = yield buildPlugin();
      }));
    }
  });

  return function buildAndWatchPlugin() {
    return _ref5.apply(this, arguments);
  };
})();

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _parseAuthor = require('parse-author');

var _parseAuthor2 = _interopRequireDefault(_parseAuthor);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _skpmConfig2 = require('@skpm/utils/skpm-config');

var _skpmConfig3 = _interopRequireDefault(_skpmConfig2);

var _webpackConfig = require('./utils/webpackConfig');

var _webpackConfig2 = _interopRequireDefault(_webpackConfig);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const buildEmojis = ['ðŸ”§', 'ðŸ”¨', 'âš’', 'ðŸ› ', 'â›', 'ðŸ”©'];
function randomBuildEmoji() {
  return buildEmojis[Math.floor(Math.random() * buildEmojis.length)];
}

var _yargs$option$option$ = _yargs2.default.option('watch', {
  alias: 'w',
  describe: 'Watch and rebuild automatically',
  type: 'boolean'
}).option('quiet', {
  alias: 'q',
  describe: 'Hide compilation warnings',
  type: 'boolean'
}).option('run', {
  alias: 'r',
  describe: 'Run plugin after compiling',
  type: 'boolean'
}).help().strict();

const argv = _yargs$option$option$.argv;


let packageJSON;
try {
  packageJSON = require(_path2.default.join(process.cwd(), 'package.json'));
} catch (err) {
  console.error(`${_chalk2.default.red('error')} Error while reading the package.json file`);
  console.error(err);
  process.exit(1);
}

const skpmConfig = (0, _skpmConfig3.default)(packageJSON);

if (!skpmConfig.main) {
  console.error(`${_chalk2.default.red('error')} Missing "skpm.main" fields in the package.json. Should point to the ".sketchplugin" file`);
  process.exit(1);
}
if (!skpmConfig.manifest) {
  console.error(`${_chalk2.default.red('error')} Missing "skpm.manifest" fields in the package.json. Should point to the "manifest.json" file`);
  process.exit(1);
}

const output = _path2.default.join(process.cwd(), skpmConfig.main);
const manifest = _path2.default.join(process.cwd(), skpmConfig.manifest);

if (!_fs2.default.existsSync(_path2.default.join(output, 'Contents', 'Sketch'))) {
  _mkdirp2.default.sync(_path2.default.join(output, 'Contents', 'Sketch'));
}

const manifestFolder = _path2.default.dirname(manifest);

const defaultAppcastURL = `https://raw.githubusercontent.com/${skpmConfig.repository}/master/.appcast.xml`;

let counter = 0;

function getCommands(manifestJSON) {
  const commandsAndHandlers = manifestJSON.commands.reduce((prev, c) => {
    if (!prev[c.script]) {
      prev[c.script] = {
        script: c.script,
        handlers: [],
        identifiers: []
      };
    }
    if (c.handler) {
      prev[c.script].handlers.push(c.handler);
    } else if (c.handlers) {
      // eslint-disable-next-line no-inner-declarations
      function getHandlers(handlers) {
        if (typeof handlers === 'string') {
          prev[c.script].handlers.push(handlers);
        } else if (Array.isArray(c.handlers)) {
          c.handlers.forEach(h => {
            prev[c.script].handlers.push(h);
          });
        } else {
          Object.keys(handlers).forEach(k => getHandlers(handlers[k]));
        }
      }
      getHandlers(c.handlers);
    }

    // always expose the default
    if (prev[c.script].handlers.indexOf('onRun') === -1) {
      prev[c.script].handlers.push('onRun');
    }
    if (c.identifier) {
      prev[c.script].identifiers.push(c.identifier);
    }
    return prev;
  }, {});

  return Object.keys(commandsAndHandlers).map(k => commandsAndHandlers[k]);
}

function getResources(_skpmConfig) {
  const resourcesArrays = _skpmConfig.resources.map(resource => _glob2.default.sync(resource));

  // flatten array
  return resourcesArrays.reduce((prev, a) => {
    a.forEach(resource => {
      prev.push(resource);
    });
    return prev;
  }, []);
}

let steps;
function checkEnd() {
  counter += 1;
  if (counter >= steps) {
    console.log(`${_chalk2.default.green('success')} Plugin built`);
    process.exit(0);
  }
}

function buildCallback(file, watching) {
  return (err, stats) => {
    if (err) {
      console.error(`${_chalk2.default.red('error')} Error while building ${file}`);
      console.error(err.stack || err);
      if (err.details) {
        console.error(err.details);
      }
      process.exit(1);
    }

    const info = stats.toJson({
      chunks: false,
      colors: true,
      modules: false,
      assets: false,
      performance: false,
      reasons: false,
      version: false
    });

    if (stats.hasErrors()) {
      console.error(`${_chalk2.default.red('error')} Error while building ${file}`);(info.errors || []).forEach(error => {
        console.error(error);
      });
      if (!watching) {
        process.exit(1);
      }
    } else {
      if (stats.hasWarnings() && !argv.quiet) {
        ;(info.warnings || []).forEach(warning => {
          console.warn(warning);
        });
      }
      console.log(`${watching ? '' : _chalk2.default.dim(`[${counter + 1}/${steps}] `)}${randomBuildEmoji()}  Built ${_chalk2.default.blue(file)} in ${_chalk2.default.grey(info.time)}ms`);
      if (!watching) {
        checkEnd();
      }
    }
  };
}

try {
  buildAndWatchPlugin();
} catch (err) {
  console.error(`${_chalk2.default.red('error')} Error while building the plugin`);
  console.error(err);
  process.exit(1);
}